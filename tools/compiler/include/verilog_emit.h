/*
 * verilog_emit.h - Verilog Backend Emission (Phase 4)
 *
 * Converts compiled ternary bytecode into a Verilog testbench
 * for the full 36-opcode ternary_processor_full module.
 * Supports both the legacy simple processor and the new FSM-based
 * processor with program-loading interface.
 */

#ifndef VERILOG_EMIT_H
#define VERILOG_EMIT_H

#include <stdio.h>
#include "vm.h"

/* Opcode name table for comments in generated Verilog */
static inline const char *verilog_opname(unsigned char op) {
    static const char *names[] = {
        "NOP", "PUSH", "ADD", "SUB", "MUL", "HALT",
        "DUP", "DROP", "SWAP", "OVER", "ROT",
        "TO_R", "FROM_R", "R_FETCH",
        "LOAD", "STORE", "CALL", "RET",
        "BRZ", "BRN", "BRP",
        "CMP_EQ", "CMP_LT", "CMP_GT",
        "NEG", "CONSENSUS", "ACCEPT_ANY",
        "ENTER", "LEAVE",
        "LOOP_BEGIN", "LOOP_END", "LOOP_I",
        "PUSH_TRYTE"
    };
    if (op < sizeof(names)/sizeof(names[0]))
        return names[op];
    return "UNKNOWN";
}

/*
 * Emit a Verilog testbench for the FULL processor (Phase 4).
 * Uses program-loading interface to write bytecode into instruction
 * memory, then resets and runs the processor to completion.
 * Returns 0 on success, -1 on error.
 */
static inline int emit_verilog_testbench_full(const unsigned char *code, int len,
                                               const char *output_path) {
    FILE *f = fopen(output_path, "w");
    if (!f) return -1;

    fprintf(f, "/*\n * Auto-generated Verilog testbench (Phase 4 full processor)\n");
    fprintf(f, " * Generated by ternary_compiler --emit-verilog\n */\n\n");
    fprintf(f, "`timescale 1ns/1ps\n\n");
    fprintf(f, "module auto_tb;\n");
    fprintf(f, "    reg clk, rst;\n");
    fprintf(f, "    reg prog_we;\n");
    fprintf(f, "    reg [7:0] prog_addr, prog_data;\n");
    fprintf(f, "    wire [17:0] tos;\n");
    fprintf(f, "    wire halted;\n");
    fprintf(f, "    wire [7:0] pc_out;\n\n");
    fprintf(f, "    ternary_processor_full dut(\n");
    fprintf(f, "        .clk(clk), .rst(rst),\n");
    fprintf(f, "        .prog_we(prog_we), .prog_addr(prog_addr),\n");
    fprintf(f, "        .prog_data(prog_data),\n");
    fprintf(f, "        .top_of_stack(tos), .halted(halted),\n");
    fprintf(f, "        .pc_out(pc_out)\n");
    fprintf(f, "    );\n\n");
    fprintf(f, "    always #5 clk = ~clk;\n\n");

    /* Task: load a byte */
    fprintf(f, "    task load_byte;\n");
    fprintf(f, "        input [7:0] addr;\n");
    fprintf(f, "        input [7:0] data;\n");
    fprintf(f, "        begin\n");
    fprintf(f, "            prog_we = 1; prog_addr = addr; prog_data = data;\n");
    fprintf(f, "            @(posedge clk); #1;\n");
    fprintf(f, "        end\n");
    fprintf(f, "    endtask\n\n");

    fprintf(f, "    initial begin\n");
    fprintf(f, "        $display(\"=== Auto-generated Testbench (Full Processor) ===\");\n");
    fprintf(f, "        clk = 0; rst = 1;\n");
    fprintf(f, "        prog_we = 0; prog_addr = 0; prog_data = 0;\n");
    fprintf(f, "        #10;\n\n");

    /* Phase 1: Load program into instruction memory */
    fprintf(f, "        // --- Load program (%d bytes) ---\n", len);
    for (int i = 0; i < len; i++) {
        fprintf(f, "        load_byte(8'd%d, 8'd%u); // %s",
                i, code[i], verilog_opname(code[i]));
        /* For PUSH, annotate with operand value */
        if (code[i] == OP_PUSH && (i + 1) < len) {
            fprintf(f, " (operand at next byte)");
        }
        fprintf(f, "\n");
    }
    fprintf(f, "\n");

    /* Phase 2: Reset and run */
    fprintf(f, "        // --- Reset and run ---\n");
    fprintf(f, "        prog_we = 0;\n");
    fprintf(f, "        rst = 1;\n");
    fprintf(f, "        @(posedge clk); @(posedge clk);\n");
    fprintf(f, "        #1; rst = 0;\n\n");

    /* Phase 3: Wait for halt */
    fprintf(f, "        // --- Wait for halt ---\n");
    fprintf(f, "        repeat (%d) begin\n", len * 10 + 20);
    fprintf(f, "            @(posedge clk); #1;\n");
    fprintf(f, "            if (halted) begin\n");
    fprintf(f, "                $display(\"Halted at PC=%%d, TOS=%%h\", pc_out, tos);\n");
    fprintf(f, "                $finish(0);\n");
    fprintf(f, "            end\n");
    fprintf(f, "        end\n\n");
    fprintf(f, "        $display(\"ERROR: Processor did not halt within timeout\");\n");
    fprintf(f, "        $finish(1);\n");
    fprintf(f, "    end\n");
    fprintf(f, "endmodule\n");

    fclose(f);
    return 0;
}

/*
 * Legacy: Emit testbench for simple ternary_processor module.
 * Kept for backward compatibility.
 */
static inline int emit_verilog_testbench(const unsigned char *code, int len,
                                          const char *output_path) {
    FILE *f = fopen(output_path, "w");
    if (!f) return -1;

    fprintf(f, "/*\n * Auto-generated Verilog testbench (legacy simple processor)\n");
    fprintf(f, " * Generated by ternary_compiler --emit-verilog\n */\n\n");
    fprintf(f, "`timescale 1ns/1ps\n\n");
    fprintf(f, "module auto_tb;\n");
    fprintf(f, "    reg clk, rst;\n");
    fprintf(f, "    reg [7:0] instr, operand;\n");
    fprintf(f, "    wire [17:0] tos;\n");
    fprintf(f, "    wire halted;\n\n");
    fprintf(f, "    ternary_processor u_proc(\n");
    fprintf(f, "        .clk(clk), .rst(rst),\n");
    fprintf(f, "        .instruction(instr), .operand(operand),\n");
    fprintf(f, "        .top_of_stack(tos), .halted(halted)\n");
    fprintf(f, "    );\n\n");
    fprintf(f, "    always #5 clk = ~clk;\n\n");
    fprintf(f, "    initial begin\n");
    fprintf(f, "        $display(\"=== Auto-generated Testbench ===\");\n");
    fprintf(f, "        clk = 0; rst = 1;\n");
    fprintf(f, "        instr = 0; operand = 0;\n");
    fprintf(f, "        #10; rst = 0;\n\n");

    for (int i = 0; i < len; ) {
        unsigned char op = code[i++];
        fprintf(f, "        // %s\n", verilog_opname(op));
        switch (op) {
            case OP_PUSH:
                if (i < len) {
                    fprintf(f, "        instr = 8'd1; operand = 8'd%u;\n", code[i]);
                    i++;
                }
                break;
            case OP_ADD:
                fprintf(f, "        instr = 8'd2; operand = 8'd0;\n");
                break;
            case OP_SUB:
                fprintf(f, "        instr = 8'd3; operand = 8'd0;\n");
                break;
            case OP_MUL:
                fprintf(f, "        instr = 8'd4; operand = 8'd0;\n");
                break;
            case OP_HALT:
                fprintf(f, "        instr = 8'd5; operand = 8'd0;\n");
                break;
            case OP_DUP:
                fprintf(f, "        instr = 8'd6; operand = 8'd0;\n");
                break;
            case OP_DROP:
                fprintf(f, "        instr = 8'd7; operand = 8'd0;\n");
                break;
            case OP_SWAP:
                fprintf(f, "        instr = 8'd8; operand = 8'd0;\n");
                break;
            case OP_OVER:
                fprintf(f, "        instr = 8'd9; operand = 8'd0;\n");
                break;
            case OP_ROT:
                fprintf(f, "        instr = 8'd10; operand = 8'd0;\n");
                break;
            case OP_STORE:
                fprintf(f, "        instr = 8'd15; operand = 8'd0;\n");
                break;
            case OP_LOAD:
                fprintf(f, "        instr = 8'd14; operand = 8'd0;\n");
                break;
            default:
                fprintf(f, "        instr = 8'd%u; operand = 8'd0;\n", op);
                break;
        }
        fprintf(f, "        @(posedge clk); #1;\n\n");
    }

    fprintf(f, "        #20;\n");
    fprintf(f, "        $display(\"Result TOS: %%b\", tos);\n");
    fprintf(f, "        $display(\"Halted: %%b\", halted);\n");
    fprintf(f, "        $finish;\n");
    fprintf(f, "    end\n");
    fprintf(f, "endmodule\n");

    fclose(f);
    return 0;
}

#endif /* VERILOG_EMIT_H */
