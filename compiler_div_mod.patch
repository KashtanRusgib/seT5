diff --git a/include/ir.h b/include/ir.h
index 3f62771..84e3a6e 100644
--- a/include/ir.h
+++ b/include/ir.h
@@ -15,7 +15,8 @@
 #include <string.h>
 
 /* AST node types */
-typedef enum {
+typedef enum
+{
     NODE_CONST,     /* Integer constant */
     NODE_VAR,       /* Variable reference */
     NODE_BINOP,     /* Binary operation */
@@ -28,33 +29,38 @@ typedef enum {
     NODE_ASSIGN,    /* Assignment: lhs = rhs */
     NODE_VAR_DECL,  /* Variable declaration: int x = expr */
     /* Phase 3: Structured control flow (Setun-70/ALGOL-60 inspired) */
-    NODE_IF,        /* if (condition) { body } [else { else_body }] */
-    NODE_WHILE,     /* while (condition) { body } */
-    NODE_FOR,       /* for (init; condition; increment) { body } */
-    NODE_BLOCK,     /* { stmt1; stmt2; ... } — statement block */
+    NODE_IF,    /* if (condition) { body } [else { else_body }] */
+    NODE_WHILE, /* while (condition) { body } */
+    NODE_FOR,   /* for (init; condition; increment) { body } */
+    NODE_BLOCK, /* { stmt1; stmt2; ... } — statement block */
     /* Phase 3: Arrays */
-    NODE_ARRAY_DECL,  /* int arr[N] or int arr[N] = {init} */
-    NODE_ARRAY_ACCESS,/* arr[index] — read */
-    NODE_ARRAY_ASSIGN,/* arr[index] = expr — write */
+    NODE_ARRAY_DECL,   /* int arr[N] or int arr[N] = {init} */
+    NODE_ARRAY_ACCESS, /* arr[index] — read */
+    NODE_ARRAY_ASSIGN, /* arr[index] = expr — write */
     /* Phase 3: Trit types */
     NODE_TRIT_VAR_DECL,  /* trit x = expr */
     NODE_TRIT_ARRAY_DECL /* trit arr[N] or trit arr[N] = {init} */
 } NodeType;
 
 /* Binary operator types */
-typedef enum {
+typedef enum
+{
     OP_IR_ADD,
     OP_IR_MUL,
     OP_IR_SUB,
     /* Phase 3: Comparison & ternary logic ops */
-    OP_IR_CMP_EQ,   /* a == b */
-    OP_IR_CMP_LT,   /* a < b */
-    OP_IR_CMP_GT,   /* a > b */
-    OP_IR_NEG       /* Ternary negation (unary) */
+    OP_IR_DIV,
+    OP_IR_MOD,
+    /* Phase 3: Comparison & ternary logic ops */
+    OP_IR_CMP_EQ, /* a == b */
+    OP_IR_CMP_LT, /* a < b */
+    OP_IR_CMP_GT, /* a > b */
+    OP_IR_NEG     /* Ternary negation (unary) */
 } OpType;
 
 /* Expression AST node */
-typedef struct Expr {
+typedef struct Expr
+{
     NodeType type;
     int val;              /* For NODE_CONST */
     char *name;           /* For NODE_VAR, NODE_FUNC_DEF, NODE_FUNC_CALL */
@@ -65,11 +71,11 @@ typedef struct Expr {
     struct Expr **params; /* FUNC_DEF: param list / FUNC_CALL: args / PROGRAM: funcs */
     int param_count;      /* Number of params / args / funcs */
     /* Phase 3: Structured control flow (Setun-70 inspired) */
-    struct Expr *condition;  /* For NODE_IF, NODE_WHILE, NODE_FOR: condition expr */
-    struct Expr *else_body;  /* For NODE_IF: else branch (NULL if no else) */
-    struct Expr *increment;  /* For NODE_FOR: increment expression */
+    struct Expr *condition; /* For NODE_IF, NODE_WHILE, NODE_FOR: condition expr */
+    struct Expr *else_body; /* For NODE_IF: else branch (NULL if no else) */
+    struct Expr *increment; /* For NODE_FOR: increment expression */
     /* Phase 3: Arrays */
-    int array_size;           /* For NODE_ARRAY_DECL: number of elements */
+    int array_size; /* For NODE_ARRAY_DECL: number of elements */
 } Expr;
 
 /* Create a constant node */
diff --git a/src/ir.c b/src/ir.c
index e749954..6cb6234 100644
--- a/src/ir.c
+++ b/src/ir.c
@@ -11,9 +11,11 @@
 #include "../include/ir.h"
 
 /* Helper: allocate and zero-init an Expr node */
-static Expr *alloc_expr(void) {
+static Expr *alloc_expr(void)
+{
     Expr *e = (Expr *)malloc(sizeof(Expr));
-    if (e == NULL) {
+    if (e == NULL)
+    {
         fprintf(stderr, "ir: malloc failed\n");
         exit(1);
     }
@@ -33,21 +35,24 @@ static Expr *alloc_expr(void) {
     return e;
 }
 
-Expr *create_const(int val) {
+Expr *create_const(int val)
+{
     Expr *e = alloc_expr();
     e->type = NODE_CONST;
     e->val = val;
     return e;
 }
 
-Expr *create_var(const char *name) {
+Expr *create_var(const char *name)
+{
     Expr *e = alloc_expr();
     e->type = NODE_VAR;
     e->name = strdup(name);
     return e;
 }
 
-Expr *create_binop(OpType op, Expr *left, Expr *right) {
+Expr *create_binop(OpType op, Expr *left, Expr *right)
+{
     Expr *e = alloc_expr();
     e->type = NODE_BINOP;
     e->op = op;
@@ -56,153 +61,209 @@ Expr *create_binop(OpType op, Expr *left, Expr *right) {
     return e;
 }
 
-void optimize(Expr *e) {
-    if (e == NULL) return;
+void optimize(Expr *e)
+{
+    if (e == NULL)
+        return;
+
+    switch (e->type)
+    {
+    case NODE_CONST:
+    case NODE_VAR:
+        return;
+
+    case NODE_BINOP:
+        /* Recurse into children first (bottom-up) */
+        optimize(e->left);
+        optimize(e->right);
+
+        /* Fold if both children are now constants */
+        if (e->left->type == NODE_CONST && e->right->type == NODE_CONST)
+        {
+            int result = 0;
+            switch (e->op)
+            {
+            case OP_IR_ADD:
+                result = e->left->val + e->right->val;
+                break;
+            case OP_IR_MUL:
+                result = e->left->val * e->right->val;
+                break;
+            case OP_IR_SUB:
+                result = e->left->val - e->right->val;
+                break;
+            case OP_IR_DIV:
+                result = (e->right->val != 0) ? e->left->val / e->right->val : 0;
+                break;
+            case OP_IR_MOD:
+                result = (e->right->val != 0) ? e->left->val % e->right->val : 0;
+                break;
+            case OP_IR_CMP_EQ:
+                result = (e->left->val == e->right->val) ? 1 : 0;
+                break;
+            case OP_IR_CMP_LT:
+                result = (e->left->val < e->right->val) ? 1 : 0;
+                break;
+            case OP_IR_CMP_GT:
+                result = (e->left->val > e->right->val) ? 1 : 0;
+                break;
+            case OP_IR_NEG:
+                result = -(e->left->val);
+                break;
+            }
 
-    switch (e->type) {
-        case NODE_CONST:
-        case NODE_VAR:
-            return;
+            /* Convert this node to a constant */
+            e->type = NODE_CONST;
+            e->val = result;
 
-        case NODE_BINOP:
-            /* Recurse into children first (bottom-up) */
-            optimize(e->left);
-            optimize(e->right);
-
-            /* Fold if both children are now constants */
-            if (e->left->type == NODE_CONST && e->right->type == NODE_CONST) {
-                int result = 0;
-                switch (e->op) {
-                    case OP_IR_ADD: result = e->left->val + e->right->val; break;
-                    case OP_IR_MUL: result = e->left->val * e->right->val; break;
-                    case OP_IR_SUB: result = e->left->val - e->right->val; break;
-                    case OP_IR_CMP_EQ: result = (e->left->val == e->right->val) ? 1 : 0; break;
-                    case OP_IR_CMP_LT: result = (e->left->val < e->right->val) ? 1 : 0; break;
-                    case OP_IR_CMP_GT: result = (e->left->val > e->right->val) ? 1 : 0; break;
-                    case OP_IR_NEG: result = -(e->left->val); break;
-                }
-
-                /* Convert this node to a constant */
-                e->type = NODE_CONST;
-                e->val = result;
-
-                /* Free children */
-                expr_free(e->left);
-                expr_free(e->right);
-                e->left = NULL;
-                e->right = NULL;
-            }
-            break;
+            /* Free children */
+            expr_free(e->left);
+            expr_free(e->right);
+            e->left = NULL;
+            e->right = NULL;
+        }
+        break;
 
-        case NODE_FUNC_DEF:
-            optimize(e->body);
-            break;
+    case NODE_FUNC_DEF:
+        optimize(e->body);
+        break;
 
-        case NODE_FUNC_CALL:
-            for (int i = 0; i < e->param_count; i++) {
-                optimize(e->params[i]);
-            }
-            break;
+    case NODE_FUNC_CALL:
+        for (int i = 0; i < e->param_count; i++)
+        {
+            optimize(e->params[i]);
+        }
+        break;
 
-        case NODE_RETURN:
-            optimize(e->left);
-            break;
+    case NODE_RETURN:
+        optimize(e->left);
+        break;
 
-        case NODE_PROGRAM:
-            for (int i = 0; i < e->param_count; i++) {
-                optimize(e->params[i]);
-            }
-            break;
+    case NODE_PROGRAM:
+        for (int i = 0; i < e->param_count; i++)
+        {
+            optimize(e->params[i]);
+        }
+        break;
 
-        case NODE_DEREF:
-            optimize(e->left);
-            break;
-
-        case NODE_ADDR_OF:
-            /* nothing to fold */
-            break;
-
-        case NODE_ASSIGN:
-            optimize(e->right);
-            break;
-
-        case NODE_VAR_DECL:
-            if (e->left) optimize(e->left);
-            break;
-
-        /* Phase 3: Structured control flow */
-        case NODE_IF:
-            if (e->condition) optimize(e->condition);
-            if (e->body) optimize(e->body);
-            if (e->else_body) optimize(e->else_body);
-            break;
-
-        case NODE_WHILE:
-            if (e->condition) optimize(e->condition);
-            if (e->body) optimize(e->body);
-            break;
-
-        case NODE_FOR:
-            if (e->left) optimize(e->left);       /* init */
-            if (e->condition) optimize(e->condition);
-            if (e->increment) optimize(e->increment);
-            if (e->body) optimize(e->body);
-            break;
-
-        case NODE_BLOCK:
-            for (int i = 0; i < e->param_count; i++) {
-                optimize(e->params[i]);
-            }
-            break;
+    case NODE_DEREF:
+        optimize(e->left);
+        break;
 
-        case NODE_ARRAY_DECL:
-            /* Optimize init values */
-            for (int i = 0; i < e->param_count; i++) {
-                optimize(e->params[i]);
-            }
-            break;
+    case NODE_ADDR_OF:
+        /* nothing to fold */
+        break;
 
-        case NODE_ARRAY_ACCESS:
-            if (e->left) optimize(e->left); /* index */
-            break;
+    case NODE_ASSIGN:
+        optimize(e->right);
+        break;
 
-        case NODE_ARRAY_ASSIGN:
-            if (e->left) optimize(e->left);  /* index */
-            if (e->right) optimize(e->right); /* value */
-            break;
+    case NODE_VAR_DECL:
+        if (e->left)
+            optimize(e->left);
+        break;
 
-        case NODE_TRIT_VAR_DECL:
-            if (e->left) optimize(e->left);
-            break;
+    /* Phase 3: Structured control flow */
+    case NODE_IF:
+        if (e->condition)
+            optimize(e->condition);
+        if (e->body)
+            optimize(e->body);
+        if (e->else_body)
+            optimize(e->else_body);
+        break;
+
+    case NODE_WHILE:
+        if (e->condition)
+            optimize(e->condition);
+        if (e->body)
+            optimize(e->body);
+        break;
+
+    case NODE_FOR:
+        if (e->left)
+            optimize(e->left); /* init */
+        if (e->condition)
+            optimize(e->condition);
+        if (e->increment)
+            optimize(e->increment);
+        if (e->body)
+            optimize(e->body);
+        break;
 
-        case NODE_TRIT_ARRAY_DECL:
-            /* Optimize init values */
-            for (int i = 0; i < e->param_count; i++) {
-                optimize(e->params[i]);
-            }
-            break;
+    case NODE_BLOCK:
+        for (int i = 0; i < e->param_count; i++)
+        {
+            optimize(e->params[i]);
+        }
+        break;
+
+    case NODE_ARRAY_DECL:
+        /* Optimize init values */
+        for (int i = 0; i < e->param_count; i++)
+        {
+            optimize(e->params[i]);
+        }
+        break;
+
+    case NODE_ARRAY_ACCESS:
+        if (e->left)
+            optimize(e->left); /* index */
+        break;
+
+    case NODE_ARRAY_ASSIGN:
+        if (e->left)
+            optimize(e->left); /* index */
+        if (e->right)
+            optimize(e->right); /* value */
+        break;
+
+    case NODE_TRIT_VAR_DECL:
+        if (e->left)
+            optimize(e->left);
+        break;
+
+    case NODE_TRIT_ARRAY_DECL:
+        /* Optimize init values */
+        for (int i = 0; i < e->param_count; i++)
+        {
+            optimize(e->params[i]);
+        }
+        break;
     }
 }
 
-void expr_free(Expr *e) {
-    if (e == NULL) return;
-    if (e->left != NULL) expr_free(e->left);
-    if (e->right != NULL) expr_free(e->right);
-    if (e->body != NULL) expr_free(e->body);
-    if (e->condition != NULL) expr_free(e->condition);
-    if (e->else_body != NULL) expr_free(e->else_body);
-    if (e->increment != NULL) expr_free(e->increment);
-    if (e->params != NULL) {
-        for (int i = 0; i < e->param_count; i++) {
+void expr_free(Expr *e)
+{
+    if (e == NULL)
+        return;
+    if (e->left != NULL)
+        expr_free(e->left);
+    if (e->right != NULL)
+        expr_free(e->right);
+    if (e->body != NULL)
+        expr_free(e->body);
+    if (e->condition != NULL)
+        expr_free(e->condition);
+    if (e->else_body != NULL)
+        expr_free(e->else_body);
+    if (e->increment != NULL)
+        expr_free(e->increment);
+    if (e->params != NULL)
+    {
+        for (int i = 0; i < e->param_count; i++)
+        {
             expr_free(e->params[i]);
         }
         free(e->params);
     }
-    if (e->name != NULL) free(e->name);
+    if (e->name != NULL)
+        free(e->name);
     free(e);
 }
 
-Expr *create_func_def(const char *name, Expr **params, int param_count, Expr *body) {
+Expr *create_func_def(const char *name, Expr **params, int param_count, Expr *body)
+{
     Expr *e = alloc_expr();
     e->type = NODE_FUNC_DEF;
     e->name = strdup(name);
@@ -212,7 +273,8 @@ Expr *create_func_def(const char *name, Expr **params, int param_count, Expr *bo
     return e;
 }
 
-Expr *create_func_call(const char *name, Expr **args, int arg_count) {
+Expr *create_func_call(const char *name, Expr **args, int arg_count)
+{
     Expr *e = alloc_expr();
     e->type = NODE_FUNC_CALL;
     e->name = strdup(name);
@@ -221,44 +283,51 @@ Expr *create_func_call(const char *name, Expr **args, int arg_count) {
     return e;
 }
 
-Expr *create_return(Expr *expr) {
+Expr *create_return(Expr *expr)
+{
     Expr *e = alloc_expr();
     e->type = NODE_RETURN;
     e->left = expr;
     return e;
 }
 
-Expr *create_program(void) {
+Expr *create_program(void)
+{
     Expr *e = alloc_expr();
     e->type = NODE_PROGRAM;
     return e;
 }
 
-void program_add_func(Expr *prog, Expr *func) {
+void program_add_func(Expr *prog, Expr *func)
+{
     prog->param_count++;
     prog->params = (Expr **)realloc(prog->params, prog->param_count * sizeof(Expr *));
-    if (prog->params == NULL) {
+    if (prog->params == NULL)
+    {
         fprintf(stderr, "ir: realloc failed\n");
         exit(1);
     }
     prog->params[prog->param_count - 1] = func;
 }
 
-Expr *create_deref(Expr *expr) {
+Expr *create_deref(Expr *expr)
+{
     Expr *e = alloc_expr();
     e->type = NODE_DEREF;
     e->left = expr;
     return e;
 }
 
-Expr *create_addr_of(Expr *var) {
+Expr *create_addr_of(Expr *var)
+{
     Expr *e = alloc_expr();
     e->type = NODE_ADDR_OF;
     e->left = var;
     return e;
 }
 
-Expr *create_assign(Expr *lhs, Expr *rhs) {
+Expr *create_assign(Expr *lhs, Expr *rhs)
+{
     Expr *e = alloc_expr();
     e->type = NODE_ASSIGN;
     e->left = lhs;
@@ -266,7 +335,8 @@ Expr *create_assign(Expr *lhs, Expr *rhs) {
     return e;
 }
 
-Expr *create_var_decl(const char *name, Expr *init) {
+Expr *create_var_decl(const char *name, Expr *init)
+{
     Expr *e = alloc_expr();
     e->type = NODE_VAR_DECL;
     e->name = strdup(name);
@@ -276,7 +346,8 @@ Expr *create_var_decl(const char *name, Expr *init) {
 
 /* === Phase 3: Structured control flow constructors === */
 
-Expr *create_if(Expr *cond, Expr *body, Expr *else_body) {
+Expr *create_if(Expr *cond, Expr *body, Expr *else_body)
+{
     Expr *e = alloc_expr();
     e->type = NODE_IF;
     e->condition = cond;
@@ -285,7 +356,8 @@ Expr *create_if(Expr *cond, Expr *body, Expr *else_body) {
     return e;
 }
 
-Expr *create_while(Expr *cond, Expr *body) {
+Expr *create_while(Expr *cond, Expr *body)
+{
     Expr *e = alloc_expr();
     e->type = NODE_WHILE;
     e->condition = cond;
@@ -293,26 +365,30 @@ Expr *create_while(Expr *cond, Expr *body) {
     return e;
 }
 
-Expr *create_for(Expr *init, Expr *cond, Expr *inc, Expr *body) {
+Expr *create_for(Expr *init, Expr *cond, Expr *inc, Expr *body)
+{
     Expr *e = alloc_expr();
     e->type = NODE_FOR;
-    e->left = init;       /* init expression */
+    e->left = init; /* init expression */
     e->condition = cond;
     e->increment = inc;
     e->body = body;
     return e;
 }
 
-Expr *create_block(void) {
+Expr *create_block(void)
+{
     Expr *e = alloc_expr();
     e->type = NODE_BLOCK;
     return e;
 }
 
-void block_add_stmt(Expr *block, Expr *stmt) {
+void block_add_stmt(Expr *block, Expr *stmt)
+{
     block->param_count++;
     block->params = (Expr **)realloc(block->params, block->param_count * sizeof(Expr *));
-    if (block->params == NULL) {
+    if (block->params == NULL)
+    {
         fprintf(stderr, "ir: realloc failed\n");
         exit(1);
     }
@@ -321,7 +397,8 @@ void block_add_stmt(Expr *block, Expr *stmt) {
 
 /* === Phase 3: Array constructors === */
 
-Expr *create_array_decl(const char *name, int size, Expr **init_values, int init_count) {
+Expr *create_array_decl(const char *name, int size, Expr **init_values, int init_count)
+{
     Expr *e = alloc_expr();
     e->type = NODE_ARRAY_DECL;
     e->name = strdup(name);
@@ -331,7 +408,8 @@ Expr *create_array_decl(const char *name, int size, Expr **init_values, int init
     return e;
 }
 
-Expr *create_array_access(const char *name, Expr *index) {
+Expr *create_array_access(const char *name, Expr *index)
+{
     Expr *e = alloc_expr();
     e->type = NODE_ARRAY_ACCESS;
     e->name = strdup(name);
@@ -339,7 +417,8 @@ Expr *create_array_access(const char *name, Expr *index) {
     return e;
 }
 
-Expr *create_array_assign(const char *name, Expr *index, Expr *value) {
+Expr *create_array_assign(const char *name, Expr *index, Expr *value)
+{
     Expr *e = alloc_expr();
     e->type = NODE_ARRAY_ASSIGN;
     e->name = strdup(name);
@@ -349,7 +428,8 @@ Expr *create_array_assign(const char *name, Expr *index, Expr *value) {
 }
 /* === Phase 3: Trit constructors === */
 
-Expr *create_trit_var_decl(const char *name, Expr *init) {
+Expr *create_trit_var_decl(const char *name, Expr *init)
+{
     Expr *e = alloc_expr();
     e->type = NODE_TRIT_VAR_DECL;
     e->name = strdup(name);
@@ -357,7 +437,8 @@ Expr *create_trit_var_decl(const char *name, Expr *init) {
     return e;
 }
 
-Expr *create_trit_array_decl(const char *name, int size, Expr **init_values, int init_count) {
+Expr *create_trit_array_decl(const char *name, int size, Expr **init_values, int init_count)
+{
     Expr *e = alloc_expr();
     e->type = NODE_TRIT_ARRAY_DECL;
     e->name = strdup(name);
@@ -365,4 +446,4 @@ Expr *create_trit_array_decl(const char *name, int size, Expr **init_values, int
     e->params = init_values;
     e->param_count = init_count;
     return e;
-}
\ No newline at end of file
+}
